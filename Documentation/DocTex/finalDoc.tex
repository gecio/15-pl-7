\documentclass[12pt,a4paper,titlepage]{report}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{enumerate}
%hiperłącza
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}
%XML
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{lightblue}{rgb}{0.0,0.0,0.9}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}
\definecolor{darkred}{rgb}{0.6,0.0,0.0}


\lstset{
  	basicstyle=\ttfamily\footnotesize,
  	columns=fullflexible,
  	showstringspaces=false,
  	numbers=left,                   % where to put the line-numbers
  	numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  	stepnumber=1,
  	numbersep=5pt,                  % how far the line-numbers are from the code
  	backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  	showspaces=false,               % show spaces adding particular underscores
  	showstringspaces=false,         % underline spaces within strings
  	showtabs=false,                 % show tabs within strings adding particular underscores
  	frame=none,    
  	xleftmargin=10px,              % adds a frame around the code
  	rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green 	here))
  	tabsize=2,                      % sets default tabsize to 2 spaces
  	captionpos=b,                   % sets the caption-position to bottom
  	breaklines=true,                % sets automatic line breaking
  	breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  	%title=\lstname,                   % show the filename of files included with \lstinputlisting;
 		                              % also try caption instead of title  
  	commentstyle=\color{gray}\upshape
}
 \lstdefinelanguage{XML}{
  	morestring=[s][\color{mauve}]{"}{"},
  	morestring=[s][\color{black}]{>}{<},
  	morecomment=[s]{<?}{?>},
  	morecomment=[s][\color{dkgreen}]{<!--}{-->},
  	stringstyle=\color{black},
  	identifierstyle=\color{lightblue},
  	keywordstyle=\color{red},
  	morekeywords={xmlns,xsi,noNamespaceSchemaLocation,type,id,x,y,source,target,version,tool,transRef,roleRef,objective,eventually},
}


\author{Katarzyna Węgiełek \\ Paweł Własiuk \\ Kamil Sienkiewicz\\ Marcin Wardziński}
\title{\textbf{Computational Cluster}}
\linespread{1.125}

\begin{document}
	\maketitle
	\tableofcontents

	\chapter{TaskSolver}
		\section{Interfejs}	
	\begin{figure}[h]
		\centering
		\caption{Interfejs pluginu}
		\includegraphics[width=0.6\textwidth]{img/taskSolverInterface.png}
	\end{figure}
	
	Komponenty systemu odpowiedzialne za wykonywanie obliczeń będą korzystały z interfejsu zaprezentowanego powyżej.
	Klasa obsługiwana przez system musi implementować 3 metody konieczne do rozwiązania zadania:
	\begin{itemize}
		\item \verb+Divide()+ - metoda, która jako parametr przyjmuje \textit{zadanie}. Jej głównym zadaniem jest podzielenie problemu
		na mniejsze łatwiejsze do rozwiązania podproblemy.
		\item \verb+Combine()+ - metoda, która w parametrze przyjmuje kolekcję częściowych rozwiązań. Jej zadaniem jest scalenie rozwiązań częściowych w jedno ostateczne rozwiązanie.
		\item \verb+Solve()+ - metoda jako parametr przyjmuje podzadanie, które powstało w wyniku działania metody \verb+Divide+. 
		Efektem działania tej metody jest rozwiązanie problemu.
	\end{itemize}		
	
	Plugin powinien również udostępniać dwa pola umożliwiające zidentyfikowanie obiektów tej samej klasy w różnych częściach systemu:
	\begin{itemize}
		\item \verb+Id+ - unikalne pole typu \verb+Guid+. System nie przewiduje istnienia dwóch różnych klas, rozwiązujących różne zadania identyfikujących się identycznym id. Taka sytuacja mogłaby doprowadzić system do błędu.
		\item \verb+ProblemClassName+ - pole typu \verb+string+ zawierające informację zrozumiałą dla użytkownika o typie problemu rozwiązywalnego przez daną klasę.
	\end{itemize}		

	Rozwiązanie problemu powinno przebiegać w poniżej podany sposób:
		\begin{enumerate}[(1)]
			\item zadanie zostaje podzielone na podzadania,
			\item każde z podzadań zostaje rozwiązane,
			\item wszystkie rozwiązania częściowe zostają przekazane jako parametr metody scalającej rozwiązania
			w wyniku czego otrzymujemy końcowe rozwiązanie naszego problemu.
		\end{enumerate}
	 \section{Instalacja Pluginów}
	Komponenty klastra odpowiedzialne za obliczenia tj. \textit{Task Manager} i \textit{Computational Node} przy każdym odpytaniu serwera o listę klas problemów, które mogą rozwiązać będą przeszukiwać folder \verb+TaskSolvers+ znajdujący się w katalogu z aplikacją, w celu poszukiwania bibliotek z klasami implementującymi interfejs \verb+TaskSolver+. Gdy komponentowi zostanie zlecone zadanie, ten wykorzystując mechanizm refleksji wyszuka w katalogu odpowiednią klasę i stworzy jej instancję. Obiekt ten  umożliwi realizacją zleconego zadania.\\
	 Instalacja nowych pluginów w komponentach systemu będzie sprowadzała się wyłącznie do wklejenie biblioteki z klasą implementującą interfejs \verb+TaskSolver+ do wyżej wymienionego katalogu.
	 
	%komunikacja + schemy
	\chapter{Komunikacja}
		\section{Nawiązywania połączenia}
	Uruchomienie całego systemu rozpoczyna się od uruchomienia \textit{Communications Server'a}. Od tej chwili komponenty systemu tj. 
	\textit{Computational node'y}	i \textit{Task Managery} mogą zgłaszać swoją obecność w klastrze. Każdy z komponentów systemu 
	posiada w swoim pliku konfiguracyjnym (w węzłach \verb+MainServerAddress+ i \verb+BackupServerAddress+) \textbf{adres IP} i
	 \textbf{port} \textit{Communications Server'a} oraz serwera zapasowego. Zaraz po uruchomieniu każdy komponent
	zgłasza swoją obecność do głównego serwera. Po trzech nieudanych próbach nawiązania połączenia następuje
	wysłanie identycznej informacji do serwera backup'owego. Każdy z komponentów w takiej wiadomości informuje o swoim rodzaju podaje
	IP i port na którym	działa. Na tej podstawie serwer będzie komunikował się z tymi elementami systemu.\\
	
		 \lstinputlisting[caption=\footnotesize{Wiadomość wysyłana przez komponent włączający się do systemu},language=XML,firstline=1,lastline=6]{examples.xml} 
		
	Parametr \verb+ComponentType+ informuje o rodzaju komponentu systemu. Wartości, które może przyjąć ten parametr to:
	\begin{itemize}
		\item \verb+TaskManager+ - w przypadku gdy wiadomość pochodzi od \textit{Task Manager'a},
		\item \verb+ComputationalNode+ - gdy wiadomość pochodzi od \textit{Computational Node'a}
	\end{itemize} 

	Zadaniem \textit{Communications Server'a} jest utrzymywanie listy aktywnych komponentów systemu, oraz przechowywanie informacji
	na temat klas problemów, które dane komponenty obsługują. W tym celu serwer regularnie, co pewien określony czas
	będzie odpytywał wszystkie swoje komponenty prosząc o listę klas problemów możliwych do rozwiązania. W przypadku gdy takiej
	odpowiedzi nie otrzyma uznaje komponent za wyłączony i usuwa jego dane z pamięci. W przypadku otrzymania odpowiedzi na
	żądanie, serwer na podstawie otrzymanych danych uzupełnia/aktualizuje informacje o rozwiązywalnych problemach
	przez komponenty.\\
	
		\lstinputlisting[caption=\footnotesize{Odpowiedź komponentu na żądanie serwera},language=XML,firstline=8,lastline=14]{examples.xml} 

	W wiadomości, dla każdego typu problemu zostają przekazane dwie informacje:
	\begin{itemize}
		\item \verb+problemClassName+ - nazwa problemu,
		\item \verb+problemClassId+ - guid problemu, który w jednoznaczny sposób identyfikuje typ problemu.	
	\end{itemize} 		
		
	\begin{figure}[h]
		\centering
		\caption{Uzyskiwanie połączenia przez komponent systemu}
		\includegraphics[width=0.8\textwidth]{img/communication/connecting.png}
	\end{figure}
	
	\section{Lista rozwiązywalnych problemów}
	Proces rozwiązywania zadania przez \textit{Computational Cluster} rozpoczyna się na poziomie \textit{Computational client'a}. Przed
	wysłaniem problemu do rozwiązania, aplikacja kliencka musi pobrać z serwera informację na temat klas problemów
	rozwiązywalnych w danej chwili przez \textit{Computational Cluster} (wynika ona z obecnie dostępnych \textit{Menadżerów zadań} i
	\textit{Computational Node'ów}). Aplikacja kliencka odpytuje \textit{serwer komunikacyjny} o potrzebne informacje. 
	Serwer w odpowiedzi na to żądanie odsyła wiadomość, w której zawarte są informacje o wszystkich typach problemów
	rozwiązywalnych przez klaster. Informacje zostają przetworzone i przedstawione użytkownikowi. Wiadomość przesłana do 
	\textit{Computational Clienta} jest identyczna z tą, którą serwer otrzymuje od pozostałych komponentów systemu.
	
	\begin{figure}[h]
		\centering
		\caption{Diagram sekwencji pobierania informacji z serwera przez \textit{Computational Client'a}}
		\includegraphics[width=0.9\textwidth]{img/communication/problemclass.png}
	\end{figure}	
	
	\section{Rozwiązywanie zadania}
	
	Po wykonaniu czynności opisanych w poprzednim rozdziale, użytkownik może zlecić zadanie \textit{klastrowi obliczeniowemu}
    \textit{Computational Client} wysyła do serwera wiadomość z informacją o typie rozwiązywanego problemu i dane wejściowe zadania.\\
    
    \lstinputlisting[caption=\footnotesize{Zlecenie rozwiązania zadania przez \textit{Computational Client'a}},language=XML,firstline=16,lastline=20]{examples.xml}
    
     Wiadomość zawiera 2 parametry konieczne do stworzenia i rozwiązania zadania:
    \begin{itemize}
    	\item \verb+problemClassId+ - identyfikator klasy problemu, umożliwiający zidentyfikowanie, które części systemu są w stanie rozwiązać dany problem
    	\item \verb+Data+ - parametry typu \verb+String+ zawierający dane wejściowe dla danego typu problemu. Dane te przedstawione są w formacie XML odpowiednim dla danego typu problemu.  
    \end{itemize}
    
    Serwer po otrzymaniu wiadomości generuje specjalny identyfikator, który przypisuje do zadania. Będzie on wykorzystany do 
    identyfikacji poszczególnych podzadań oraz umożliwi klientowi zidentyfikowanie zleconego zadania.\\
    
    \lstinputlisting[caption=\footnotesize{Informacja z tokenem zwracana do aplikacji klienckiej},language=XML,firstline=22,lastline=25]{examples.xml}
    
    Taki token zostaje również odesłany do aplikacji klienckiej, która zapisze go w swoim pliku konfiguracyjnym. Poniżej przykład prezentujący odpowiedni wpis:
    
    \begin{lstlisting}[language=XML,numbers=none]
    <TaskList>
    	<Task taskname="customTaskName1" taskToken="ee28fec2-6361-4a58-aaf1-b9ff0f509743"/>
    	<Task taskname="customTaskName2" taskToken="4fbcbba1-014e-4643-b60f-f7888a95bb54"/>
    </TaskList>
    \end{lstlisting}
    Węzeł \verb+Task+ odpowiada jednemu zleconemu zadaniu przez użytkownika. Każdy taki węzeł posiada dwa atrybuty:
	
	\begin{itemize}
		\item \verb+taskToken+ - to identyfikator zadania nadany przez klaster obliczeniowy, dzięki niemu użytkownik będzie miał możliwość pobrania rozwiązania zadania,
		\item \verb+taskname+ - nazwa zadania nadana przez użytkownika, która umożliwi mu zidentyfikowanie zadania, nazwa obecna wyłącznie na poziomie aplikacji klienckiej.
	\end{itemize}	    
      
	
	\begin{figure}[h]
		\centering
		\caption{Diagram sekwencji pobierania informacji z serwera przez \textit{Computational Client'a}}
		\includegraphics[width=\textwidth]{img/communication/computation.png}
	\end{figure}    
    
    
    \textit{Computational Cluster} wykonuje ciąg czynności koniecznych do otrzymania rozwiązania, tzn:
	\begin{enumerate}[(1)]
		\item przesłanie polecenia podziału zadania od \textit{serwera} do \textit{Task Manager'a} - wiadomość w formacie otrzymanym od \textit{Computational Client'a},
		\item podział zadania i odesłanie stworzonych podproblemów prowadzących do otrzymania rozwiązania. \textit{Task Manager} dokonuje podziału zadania, każdemu z nich przydzielając unikalny identyfikator. Wiadomość zwrotna zawiera informacje o 
		typie rozwiązywalnego problemu, identyfikatora zadania, identyfikatora podzadania, oraz danych wejściowych potrzebnych do rozwiązania zadania.
		
		\lstinputlisting[caption=\footnotesize{Zlecenie podzadania},language=XML,firstline=36,lastline=42]{examples.xml}
		
		\item przesłanie każdego z podzadań do \textit{węzłów obliczeniowych}
		\item przeprowadzenie obliczeń i odesłanie częściowych rozwiązań do \textit{serwera}. Odsyłana wiadomość zawiera informacje o 
		typie rozwiązywalnego podproblemu, identyfikatorze zadania, identyfikatorze podzadania oraz rozwiązaniu częściowym problemu.
		\item przesłanie częsciowych rozwiązań do \textit{Task Managera} w celu stworzenia rozwiązania. Przesłanie wiadomości wcześniej zebranych od \textit{Computational Node'ów}.
		\item odesłanie pełnego rozwiązania zadania do \textit{serwera} w identycznym formacie jak te, które serwer odsyła do \textit{Computational Clienta}
	\end{enumerate}

	Zadanie przesłane do podziału przez \textit{Communications server} jest w formacie otrzymanym od \textit{Computational Client'a}    
    
    \section{Odczytanie rozwiązania}	
	Proces odczytywania rozwiązania zadania rozpoczyna się od załadowania listy zadań zleconych przez daną aplikację z pliku konfiguracyjnego do którego wcześniej zostały wpisane identyfikatory poszczególnych zadań. Użytkownik wybiera zadanie którego rozwiązanie
	chce pobrać. Aplikacja odpytuje serwer o rozwiązanie, w wyniku czego otrzymuje informację na jego temat. Wiadomość, którą wysyła aplikacja kliencka w węźle \verb+TaskId+ zawiera identyfikator zadania którego rozwiązania oczekujemy.\\

	 \lstinputlisting[caption=\footnotesize{Rozwiązanie zadania},language=XML,firstline=28,lastline=34]{examples.xml}

	\begin{figure}[h]
		\centering
		\caption{Diagram sekwencji pobierania informacji z serwera przez aplikację kliencką}
		 \includegraphics[width=\textwidth]{img/communication/getresult.png}
	\end{figure} 	
	
	Wiadomość otrzymana od serwera składa się z 4 węzłów:
	\begin{itemize}
		\item \verb+problemClassId+ - identyfikator klasy problemów, której dotyczy zadanie. Informacja potrzebna do odpowiedniego wyboru 
		pluginu, który odpowiednio sparsuje i przedstawi wyniki użytkownikowi.
		\item \verb+TaskId+ - identyfikator zadania
		\item \verb+Status+ - dwie możliwe wartości to \verb+Done+ - jeżeli zadanie zostało ukończone oraz \verb+InProgress+ - jeżeli rozwiązywanie zadania nadal trwa.
		\item \verb+Data+ - w przypadku gdy status przyjmuję wartość \verb+Done+ pole zawiera rozwiązanie zadania w postaci XML,
		w przeciwnym przypadku wartość jest pusta
	\end{itemize}
	
	
	\section{Schema}
		\subsection{Uzyskiwanie połączenia przez komponenty}	
			\lstinputlisting[language=XML]{schema/connectionMessageSchema.xsd}
		\subsection{Lista rozwiązywalnych problemów przez klaster obliczeniowy}
			\lstinputlisting[language=XML]{schema/SolvableProblemListMessage.xsd}
		\subsection{Zlecenie rozwiązania zadania}
			\lstinputlisting[language=XML]{schema/TaskOrderMessage.xsd}
		\subsection{Token wysyłany do aplikacji klienckiej}
			\lstinputlisting[language=XML]{schema/TaskTokenMessage.xsd}
		\subsection{Żądanie o przesłanie rozwiązania zadania}
			\lstinputlisting[language=XML]{schema/TaskResultRequestMessage.xsd}
		\subsection{Rozwiązanie Zadania}
			\lstinputlisting[language=XML]{schema/TaskResultMessage.xsd}
		\subsection{Zlecenie rozwiązania podzadania}
			\lstinputlisting[language=XML]{schema/SubtaskOrderMessage.xsd}
		\subsection{Przesłanie rozwiązania podzadania}
			\lstinputlisting[language=XML]{schema/SubtaskResultMessage.xsd}
\end{document}